import{ax as S,al as l,z as p,A as m,B as s,R as t,aL as r,O as o,J as d}from"./chunks/framework.CiWjUW6V.js";const P=JSON.parse('{"title":"原生特性开发","description":"了解如何开发适配 ShiroSU 原生 root 的模块","frontmatter":{"layout":"doc","icon":"cpu","title":"原生特性开发","description":"了解如何开发适配 ShiroSU 原生 root 的模块","outline":"deep","footer":true,"breadcrumbs":[{"title":"OOM-WG","link":"/ssu"},{"title":"dev","link":""},{"title":"module","link":"/ssu/dev/module"},{"title":"原生特性开发","link":"/ssu/dev/module/root"}]},"headers":[],"relativePath":"ssu/dev/module/root.md","filePath":"ssu/dev/module/root.md","lastUpdated":1761491518000}'),h={name:"ssu/dev/module/root.md"};function b(g,e,f,_,k,U){const i=l("ArticleMetadata"),n=l("NolebasePageProperties"),a=l("VPNolebaseInlineLinkPreview"),c=l("NolebaseGitContributors"),u=l("NolebaseGitChangelog");return m(),p("div",null,[e[11]||(e[11]=s("h1",{id:"原生特性开发",tabindex:"-1"},[s("strong",null,"原生特性开发"),o(),s("a",{class:"header-anchor",href:"#原生特性开发","aria-label":"Permalink to “原生特性开发”"},"​")],-1)),t(i),t(n),e[12]||(e[12]=r('<div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>ShiroSU 的原生 root 还在开发中，具体内容随时可能变动！</p></div><p>对于大部分内容，ShiroSU 与 <strong><code>Magisk</code> 和 <code>KernelSU</code></strong> 基本保持一致，此处仅介绍不同之处</p><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>请确保模块内的所有文本文件均使用 <code>UNIX (LF)</code> 换行类型，而不是 <code>Windows (CR + LF)</code> 或 <code>Macintosh (CR)</code>！</p></div><h2 id="模块系统" tabindex="-1">模块系统 <a class="header-anchor" href="#模块系统" aria-label="Permalink to “模块系统”">​</a></h2><h3 id="systemless" tabindex="-1">Systemless <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <a class="header-anchor" href="#systemless" aria-label="Permalink to “Systemless”">​</a></h3><p>ShiroSU 的 Systemless 是一种类似于 Magisk 的挂载机制，其接口完全兼容 Magisk，例如 <code>.replace</code> 用法， 但 ShiroSU 的挂载机制兼容性更强，是基于动态识别分区实现的， 也就是说，模块可以直接通过 Systemless 挂载例如 <code>odm</code> 以及其他 root 实现无法挂载的分区，无需为此而付出额外的心血</p><p>并且，为了保证更强的安全性，ShiroSU 的 Systemless 会无视模块挂载的 <strong>文件/目录的 SELinux 上下文</strong>、<strong>目录的权限</strong>以及* *文件/目录的用户/组<strong>， 如果文件挂载到了不存在的目录，那么其 <strong>SELinux 上下文</strong>、</strong>权限<strong>、</strong>用户/组**均会继承自父目录。通常来说，这些行为不会影响模块的运行，反而有助于提高稳定性</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>ShiroSU 的 Systemless 会使用模块目录中的 <code>systemless</code> 文件夹执行挂载， 如果模块通过 <code>system</code> 文件夹使用 Systemless，那么 <code>systemless</code> 文件夹会被<strong>自动创建</strong></p><p>如果模块仅适配 ShiroSU，那么可以直接通过 <code>systemless</code> 文件夹使用 Systemless</p></div><h3 id="shell" tabindex="-1">Shell <a class="header-anchor" href="#shell" aria-label="Permalink to “Shell”">​</a></h3><p>ShiroSU 在此处与其他 root 实现有较大差异，ShiroSU 运行的 Shell 脚本默认<strong>并不</strong>在 <code>BusyBox</code> 中以 “独立模式” 运行。</p>',10)),s("p",null,[e[2]||(e[2]=o("为了提升 Shell 脚本开发的便利性， ShiroSU 使用 ",-1)),t(a,{href:"https://github.com/shellgei/rusty_bash",target:"_blank",rel:"noreferrer"},{default:d(()=>[...e[0]||(e[0]=[o("sush",-1)])]),_:1}),e[3]||(e[3]=o(" (用 Rust 编写的 ",-1)),e[4]||(e[4]=s("code",null,"Bash",-1)),e[5]||(e[5]=o(") 运行 Shell 脚本， 并且优先使用 ",-1)),t(a,{href:"https://github.com/uutils/coreutils",target:"_blank",rel:"noreferrer"},{default:d(()=>[...e[1]||(e[1]=[o("uutils",-1)])]),_:1}),e[6]||(e[6]=o(" (用 Rust 编写的 ",-1)),e[7]||(e[7]=s("code",null,"coreutils",-1)),e[8]||(e[8]=o(") 的命令集，以 Magisk 的 BusyBox 作为替补。 也就是说，命令",-1)),e[9]||(e[9]=s("strong",null,"优先从 uutils 获取",-1)),e[10]||(e[10]=o("，没有的命令才会从 BusyBox 获取",-1))]),e[13]||(e[13]=r('<p>由于并不在 BusyBox 中以 “独立模式” 运行，命令都是通过 <code>PATH</code> 环境变量注入的，请勿在模块的 Shell 脚本内硬编码修改 <code>PATH</code>！</p><h4 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to “环境变量”">​</a></h4><p>为了便于区分，ShiroSU 在模块运行时注入以下变量:</p><ul><li><code>SSU</code> (布尔值): 在 ShiroSU 环境下运行时，此值将为 <code>true</code><blockquote><p>但这并不能代表可以通过 <code>$SSU &amp;&amp; # code ...</code> 来执行代码，应当始终使用 <code>[ &quot;$SSU&quot; = true ]</code> 或类似方法来检测 ShiroSU</p></blockquote></li><li><code>SSU_VER</code> (字符串): ShiroSU 的版本号 (不包括补丁号)</li><li><code>SSU_VER_CODE</code> (整数值): ShiroSU 的纯数字版本号 (包括补丁号)</li></ul><h4 id="recovery" tabindex="-1">Recovery <a class="header-anchor" href="#recovery" aria-label="Permalink to “Recovery”">​</a></h4><p>ShiroSU 不支持通过 Recovery 安装模块， 并且在模块安装时 <code>META-INF/com/google/android/update-binary</code> 中的代码不会被执行</p><h4 id="su-调用" tabindex="-1">SU 调用 <a class="header-anchor" href="#su-调用" aria-label="Permalink to “SU 调用”">​</a></h4><p>ShiroSU 的 SU 实现默认附带了一个仅能用于直接执行 Shell 命令的 <code>sudo</code>，可以直接通过 <code>sudo</code> 来执行例如 <code>sudo ls /</code>。</p><p><code>sudo</code> 仅作为一个简易的 <code>su -c</code> 替代品而存在，但是任何模块内都<strong>不应该</strong>通过 <code>sudo</code> 或 <code>su -c</code> 执行 Shell 命令！</p><p><mark>同样的，任何模块也<strong>不应该</strong>通过<strong>硬编码</strong>来获取命令，例如 <code>/data/adb/ssu/bin/busybox crond</code>， 因为无论是在 BusyBox 的 “独立模式” 还是直接通过 <code>PATH</code> 注入命令，命令都已经可以直接调用，无需任何硬编码的手动获取行为。</mark></p>',10)),t(c),t(u),e[14]||(e[14]=r('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Systemless 机制是一种无需直接修改系统分区即可实现修改系统文件的方法，为模块提供了便利性 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',2))])}const T=S(h,[["render",b]]);export{P as __pageData,T as default};
